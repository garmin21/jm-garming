(window.webpackJsonp=window.webpackJsonp||[]).push([[112],{691:function(e,t,r){"use strict";r.r(t);var s=r(10),a=Object(s.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"简介"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[e._v("#")]),e._v(" 简介")]),e._v(" "),r("p",[e._v("Promise 对象用于表示一个异步操作的最终完成 (或失败), 及其结果值.")]),e._v(" "),r("h2",{attrs:{id:"_1-描述"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-描述"}},[e._v("#")]),e._v(" 1. 描述")]),e._v(" "),r("p",[e._v("Promise 对象是一个代理对象（代理一个值），被代理的值在 Promise 对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的 promise 对象")]),e._v(" "),r("p",[e._v("一个 Promise 有以下几种状态:")]),e._v(" "),r("ol",[r("li",[e._v("pending: 初始状态，既不是成功，也不是失败状态。")]),e._v(" "),r("li",[e._v("fulfilled: 意味着操作成功完成。")]),e._v(" "),r("li",[e._v("rejected: 意味着操作失败。")])]),e._v(" "),r("p",[e._v("pending 状态的 Promise 对象可能会变为 fulfilled 状态并传递一个值给相应的状态处理方法，也可能变为失败状态（rejected）并传递失败信息。当其中任一种情况出现时，Promise 对象的 then 方法绑定的处理方法（handlers ）就会被调用（then 方法包含两个参数：onfulfilled 和 onrejected，它们都是 Function 类型。当 Promise 状态为 fulfilled 时，调用 then 的 onfulfilled 方法，当 Promise 状态为 rejected 时，调用 then 的 onrejected 方法， 所以在异步操作的完成和绑定处理方法之间不存在竞争）。")]),e._v(" "),r("p",[e._v("因为 Promise.prototype.then 和 Promise.prototype.catch 方法返回 promise 对象， 所以它们可以被链式调用。")]),e._v(" "),r("img",{attrs:{title:"promise工作流程图",src:e.$withBase("/33.png"),width:"100%",height:"100%",alt:"1"}}),e._v(" "),r("h2",{attrs:{id:"_2-方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-方法"}},[e._v("#")]),e._v(" 2. 方法")]),e._v(" "),r("h3",{attrs:{id:"promise-all-iterable"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise-all-iterable"}},[e._v("#")]),e._v(" Promise.all(iterable);")]),e._v(" "),r("p",[e._v("参数可以是 array 或 string")]),e._v(" "),r("p",[e._v("Promise.all(iterable) 方法返回一个 Promise 实例，此实例在 iterable 参数内所有的 promise 都“完成（resolved）”或参数中不包含 promise 时回调完成（resolve）；如果参数中 promise 有一个失败（rejected），此实例回调失败（reject），失败原因的是第一个失败 promise 的结果")]),e._v(" "),r("p",[r("strong",[e._v("缺点：必须等待所有的 promise 都是成功，如果有一个不成功，结果就是不成功 promise, 假如在完成多个异步请求，使用 all 的情况 下，如果有一个接口挂掉，那么其他成功的接口，将没有意义. 返回只返回失败的 promise")])]),e._v(" "),r("img",{attrs:{src:e.$withBase("/34.png"),width:"100%",height:"100%",alt:"1"}}),e._v(" "),r("h3",{attrs:{id:"promise-race-iterable"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise-race-iterable"}},[e._v("#")]),e._v(" Promise.race(iterable);")]),e._v(" "),r("p",[e._v("race 函数返回一个 Promise，它将与第一个传递的 promise 相同的完成方式被完成。它可以是完成（ resolves），也可以是失败（rejects），这要取决于第一个完成的方式是两个中的哪个。如果传的迭代是空的，则返回的 promise 将永远等待， 如果迭代包含一个或多个非承诺值和/或已解决/拒绝的承诺，则 Promise.race 将解析为迭代中找到的第一个值。")]),e._v(" "),r("p",[r("strong",[e._v("换句话说就是类似于抢票，谁抢到归谁，失败或成功后都代表 race 函数被执行完")])]),e._v(" "),r("img",{attrs:{src:e.$withBase("/35.png"),width:"100%",height:"100%",alt:"1"}}),e._v(" "),r("h3",{attrs:{id:"promise-allsettled-iterable"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise-allsettled-iterable"}},[e._v("#")]),e._v(" Promise.allSettled(iterable);")]),e._v(" "),r("p",[e._v("Promise.allSettled()方法返回一个 promise，该 promise 在所有给定的 promise 已被解析或被拒绝后解析，并且每个对象都描述每个 promise 的结果，Promise.allSettled() 不管什么状态 都会收集起来 ，")]),e._v(" "),r("p",[e._v("其回调函数的参数返回的数组的每一项是一个包含 status 和 value 或者 reason 的一组对象。status 代表对应的参数实例状态值，取值只有 fulfilled（resolve 状态）和 rejected（reject 状态），当 status 的值为 rejected，对应的另一个对象属性就是 reason 了，也就是被 reject 的原因，而成功返回的 status 的值则是 fulfilled，对应的另一个对象属性便是 value，对应的值就是 resolve 的任意值。")]),e._v(" "),r("img",{attrs:{src:e.$withBase("/36.png"),width:"100%",height:"100%",alt:"1"}})])}),[],!1,null,null,null);t.default=a.exports}}]);