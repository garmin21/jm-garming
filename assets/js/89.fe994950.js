(window.webpackJsonp=window.webpackJsonp||[]).push([[89],{664:function(e,t,l){"use strict";l.r(t);var a=l(10),c=Object(a.a)({},(function(){var e=this,t=e.$createElement,l=e._self._c||t;return l("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[l("h2",{attrs:{id:"简介"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[e._v("#")]),e._v(" 简介")]),e._v(" "),l("p",[e._v("Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与 proxy handlers 的方法相同。Reflect 不是一个函数对象，因此它是不可构造的。")]),e._v(" "),l("h2",{attrs:{id:"描述"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#描述"}},[e._v("#")]),e._v(" 描述")]),e._v(" "),l("p",[e._v("与大多数内置对象不同，Reflect 不是一个构造函数。你不能将其与一个 new 运算符一起使用，或者将 Reflect 对象作为一个函数来调用。Reflect 的所有属性和方法都是静态的（就像 Math 对象）。")]),e._v(" "),l("p",[e._v("Reflect 对象提供了以下静态方法，这些方法与 proxy handler methods 的命名相同.")]),e._v(" "),l("p",[e._v("Reflect 是为了操作对象而提供的新的 API, Proxy 同样也是")]),e._v(" "),l("p",[e._v("Reflect 存在的原因是因为 ：")]),e._v(" "),l("ol",[l("li",[l("p",[e._v("你可以把 Reflect 对象看作是 Object 对象，Object 对象身上有的方法，Reflect 同样有，未来新的方法同样会新增到 Reflect 对象上")])]),e._v(" "),l("li",[l("p",[e._v("让修改对象的属性变的更加合理，Object.defineProperty(obj, name, desc) 在无法定义属性时，会抛出一个错误，而 Reflect.defineProperty(obj, name, desc)则会返回 false。")])]),e._v(" "),l("li",[l("p",[e._v("让 Object 操作都变成函数行为 , 列如 'name' in obj 使用 Reflect.has(Object, 'assign') 代替")])])]),e._v(" "),l("p",[e._v("作用：确保对象的属性能正确赋值，广义上讲，即确保对象的原生行为能够正常进行，这就是 Reflect 的作用")])])}),[],!1,null,null,null);t.default=c.exports}}]);