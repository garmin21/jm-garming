(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{620:function(t,s,a){"use strict";a.r(s);var n=a(10),r=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[a("a",{attrs:{href:"https://webpack.docschina.org/configuration/",target:"_blank",rel:"noopener noreferrer"}},[t._v("webpack 文档"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("webpack 的 resolve 配置模块如何解析。")]),t._v(" "),a("ol",[a("li",[a("p",[a("strong",[t._v("resolve.alias")]),t._v("：创建 import 或 require 的别名，来确保模块引入变得更简单。例如，一些位于 src/ 文件夹下的常用模块")]),t._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[t._v("  module.exports = "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//...")]),t._v("\n    resolve"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      alias"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        Utilities"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" path.resolve(__dirname"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 'src/utilities/')"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        Templates"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" path.resolve(__dirname"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 'src/templates/')\n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(";\n\n也可以在给定对象的键后的末尾添加 $，以表示精准匹配：\n\n  module.exports = "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n")])])])])]),t._v(" "),a("p",[t._v("//...\nresolve: {\nalias: {\nxyz$: path.resolve(__dirname, 'path/to/file.js')\n}\n}\n};\n```")]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[a("strong",[t._v("enforceExtension")]),t._v("：是否启用文件后缀名才能被编译 默认不需要，开启将强制需要书写扩展名")])]),t._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[t._v("module.exports = "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//...")]),t._v("\n  resolve"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    enforceExtension"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(";\n\n")])])]),a("ol",{attrs:{start:"3"}},[a("li",[a("strong",[t._v("extensions")]),t._v("：自动省略扩展名")])]),t._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[t._v("    在 Webpack 中，`resolve.extensions` 是用于配置在引入模块时可以省略的文件扩展名的选项。通过配置 `resolve.extensions`，可以告诉 Webpack 在解析模块路径时自动匹配指定的文件扩展名，从而在引入模块时可以省略文件扩展名。\n\n例如，如果你希望在引入模块时可以省略 `.js` 和 `.jsx` 文件的扩展名，可以这样配置 `resolve.extensions`：\n\nmodule.exports = "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  resolve"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    extensions"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("'.js'"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" '.jsx'"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(";\n\n在上面的配置中，`resolve.extensions` 被设置为 `"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("'.js'"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" '.jsx'"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("`，这样当你在代码中引入一个模块时，Webpack 会自动尝试匹配该模块对应的文件路径，可以省略文件扩展名 `.js` 和 `.jsx`。\n\n通过合理配置 `resolve.extensions`，可以简化模块引入时的书写，提高开发效率。但需要注意的是，过多的扩展名可能会降低解析速度并引起一些意外的行为，因此建议只配置项目中实际使用的文件扩展名。\n")])])]),a("ol",{attrs:{start:"4"}},[a("li",[a("p",[a("strong",[t._v("plugins")]),t._v("：应该使用的额外的解析插件列表。它允许插件")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("library")]),t._v("：如果需要将输出文件作为一个库来使用，可以通过该选项指定库的名称。\n在 webpack 中，"),a("code",[t._v("library")]),t._v(" 选项用于指定如何导出 library，以便在其他项目或环境中使用。通过配置 "),a("code",[t._v("library")]),t._v("，你可以将你的代码打包成一个库（library），使其可以被其他模块引入并使用。")])])]),t._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[t._v("    module.exports = "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//...")]),t._v("\noutput"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  library"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" 'MyLibrary'\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(";\n\n")])])]),a("p",[a("code",[t._v("library")]),t._v(" 可以配置为一个字符串或对象，具体取决于你希望如何导出你的库。以下是一些常见的用法：")]),t._v(" "),a("ol",[a("li",[a("p",[a("strong",[t._v("将库暴露给全局变量")]),t._v("：通过设置 "),a("code",[t._v("library")]),t._v(" 为一个字符串，可以将库暴露为一个全局变量，从而可以在浏览器环境下直接访问该库。")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[t._v("module"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("exports "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("output")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("library")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'MyLibrary'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("将库暴露给 CommonJS 模块")]),t._v("：通过设置 "),a("code",[t._v("library")]),t._v(" 为一个对象，可以将库暴露为一个 CommonJS 模块，以便在 Node.js 等环境中使用。")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[t._v("module"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("exports "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("output")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("library")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("type")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'commonjs2'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'MyLibrary'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("将库暴露给 AMD 模块")]),t._v("：也可以将库暴露为一个 AMD 模块，以便在浏览器环境中使用 RequireJS 等模块加载器。")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[t._v("module"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("exports "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("output")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("library")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("type")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'amd'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'MyLibrary'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])])]),t._v(" "),a("p",[t._v("通过配置 "),a("code",[t._v("library")]),t._v("，你可以根据需要将你的代码打包成不同类型的库，并指定如何在不同环境下使用这个库。这样可以更灵活地管理和共享你的代码。")]),t._v(" "),a("ol",{attrs:{start:"6"}},[a("li",[a("strong",[t._v("libraryTarget")]),t._v("：指定以何种方式导出库，比如 commonjs、amd、umd 等。")])]),t._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[t._v("    webpack 中的 `libraryTarget` 配置项用于指定以何种方式导出库。当你将打包后的文件作为一个库供他人使用时，`libraryTarget` 非常有用。以下是一些常见的 `libraryTarget` 可选项：\n\n    "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(". **var**：将库暴露为一个变量，适用于浏览器环境。\n    "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(". **commonjs**：将库暴露为 CommonJS 模块，适用于 Node.js 环境。\n\n    "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v(". **commonjs2**：和 commonjs 类似，但返回的是 module.exports.default。\n\n    "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),t._v(". **amd**：将库暴露为 AMD 模块，适用于 RequireJS 等 AMD 加载器。\n\n    "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v(". **umd**：通用模块定义，可以在 CommonJS、AMD 和全局变量使用。\n\n    "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),t._v(". **this**：将库绑定到 this 上，适用于全局变量和 CommonJS 模块。\n\n    "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("7")]),t._v(". **window**：将库暴露为全局变量，在浏览器中使用。\n\n    通过设置 `libraryTarget`，你可以根据需要选择合适的导出方式，以确保你的库能够在不同的环境中被正确引用和调用。这样可以增加库的灵活性和可移植性，使其更易于被其他开发者使用。\n\n")])])]),a("ol",{attrs:{start:"7"}},[a("li",[a("strong",[t._v("pathinfo")]),t._v("：指定是否在输出文件中包含有关模块路径信息。")])]),t._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[t._v("    值为 "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v(" 或者 "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),t._v(".\n\n    默认 webpack 会在输出的 bundle 中生成路径信息，设置为"),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),t._v("将路径信息删除可小幅提升构建速度。\n\n")])])]),a("ol",{attrs:{start:"8"}},[a("li",[a("strong",[t._v("sourceMapFilename")]),t._v("：指定输出的 source map 文件名称。")])]),t._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[t._v("    在 webpack 中，`sourceMapFilename` 选项用于指定生成的 source map 文件的名称。source map 是一种文件，其中包含了原始源代码和转换后的代码之间的映射关系，它能够帮助开发者在调试阶段更容易地定位到源代码中的问题。\n\n    通过配置 `sourceMapFilename`，你可以指定生成的 source map 文件的名称和路径。通常情况下，你可以使用占位符（placeholders）来动态地生成文件名，比如 `"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("`、`"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("`、`"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("hash"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("` 等。\n\n    例如，如果你设置了 `sourceMapFilename` 为 `sourcemap/"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("file"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(".map`，那么生成的 source map 文件会被放置在一个名为 `sourcemap` 的目录下，并且文件名会与对应的 JavaScript 文件名相同，只是后缀变为 `.map`。\n\n    正确配置 `sourceMapFilename` 可以帮助你管理和组织生成的 source map 文件，使其与对应的 JavaScript 文件关联并且易于在调试时使用。\n\n")])])]),a("ol",{attrs:{start:"9"}},[a("li",[a("strong",[t._v("assetModuleFilename")]),t._v(" 是 webpack 配置中用来指定生成的静态资源文件名规则的一个选项")])]),t._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[t._v("    `assetModuleFilename` 是 webpack 配置中用来指定生成的静态资源文件名规则的一个选项。通过配置 `assetModuleFilename`，可以控制 webpack 如何命名生成的资源文件，比如图片、字体等。\n\n例如，可以这样配置 `assetModuleFilename`：\n\n  module.exports = "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//...其他配置")]),t._v("\n    output"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      assetModuleFilename"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" 'images/"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("ext"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("'\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(";\n上面的配置将会把所有的静态资源文件都放在 `images` 文件夹下，文件名保持原始文件名不变，这样生成的图片文件就会被命名为 `images/example.jpg`。根据具体需求，你可以根据自己的项目结构和规范来配置 `assetModuleFilename`。\n\n")])])]),a("ol",{attrs:{start:"10"}},[a("li",[a("p",[a("strong",[t._v("auxiliaryComment")]),t._v(" 为生成插入注释")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("chunkLoadTimeout")]),t._v(" chunk 请求到期毫秒数，默认为 120 000")])])]),t._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[t._v("  在 webpack 中，`chunkLoadTimeout` 是用来指定加载代码块（chunk）的超时时间的选项。当使用动态导入（dynamic import）或 `import()` 来异步加载代码块时，如果加载超时，webpack 将会采取相应的处理方式。\n\n通过配置 `chunkLoadTimeout`，你可以指定加载代码块的超时时间，单位是毫秒。如果代码块在指定的超时时间内没有成功加载，webpack 将会触发相应的处理逻辑，比如显示错误信息或者执行其他自定义的操作。\n\n例如，你可以这样配置 `chunkLoadTimeout`：\n\nmodule.exports = "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//...其他配置")]),t._v("\n  performance"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    chunkLoadTimeout"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("120000")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(";\n\n在上面的配置中，`chunkLoadTimeout` 被设置为 "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("120000")]),t._v(" 毫秒（即 "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" 分钟）。这意味着如果一个代码块加载超过 "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" 分钟仍未完成，webpack 将会触发相应的性能处理逻辑。\n\n通过合理配置 `chunkLoadTimeout`，你可以控制代码块加载的超时行为，从而优化用户体验和应用程序的性能。\n\n\n")])])]),a("ol",{attrs:{start:"12"}},[a("li",[a("strong",[t._v("crossOriginLoading")])])]),t._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[t._v("在 webpack 中，`crossOriginLoading` 是用于配置加载跨域资源的选项。当你需要从不同源加载资源时（比如从 CDN 加载 JavaScript 文件），可以通过配置 `crossOriginLoading` 来指定在加载这些资源时使用何种跨域策略。\n\n具体而言，`crossOriginLoading` 可以设置为以下几种值：\n\n- `"),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"anonymous"')]),t._v("`：表示以匿名方式加载跨域资源，不发送用户凭据（如 cookie）。\n- `"),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"use-credentials"')]),t._v("`：表示以使用凭据的方式加载跨域资源，会发送用户凭据（如 cookie）。\n\n例如，你可以这样配置 `crossOriginLoading`：\n\nmodule.exports = "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//...其他配置")]),t._v("\n  output"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    crossOriginLoading"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" 'anonymous'\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(";\n\n在上面的配置中，`crossOriginLoading` 被设置为 `'anonymous'`，意味着在加载跨域资源时将以匿名方式进行加载。\n\n通过合理配置 `crossOriginLoading` 选项，你可以控制 webpack 在加载跨域资源时的行为，确保符合安全性和性能的要求。\n\n")])])]),a("ol",{attrs:{start:"13"}},[a("li",[a("strong",[t._v("jsonpScriptType")])])]),t._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[t._v("在 webpack 中，`jsonpScriptType` 是一个配置选项，用于指定动态加载的 JSONP 脚本标签的 `type` 属性。JSONP（JSON with Padding）是一种跨域数据请求方式，通常用于在浏览器中进行跨域数据获取。\n\n通过配置 `jsonpScriptType`，你可以指定 webpack 在动态加载代码块时使用的 JSONP 脚本标签的 `type` 属性，以便适应不同环境或需求。\n\n例如，你可以这样配置 `jsonpScriptType`：\n\n\nmodule.exports = "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//...其他配置")]),t._v("\n  output"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    jsonpScriptType"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" 'module'\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(";\n\n\n在上面的配置中，`jsonpScriptType` 被设置为 `'module'`，表示在动态加载代码块时将使用带有 `type="),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"module"')]),t._v("` 属性的 JSONP 脚本标签。\n\n通过合理配置 `jsonpScriptType` 选项，你可以控制 webpack 在动态加载代码块时生成的 JSONP 脚本标签的 `type` 属性，以适配不同的场景和需求。\n\n")])])]),a("ol",{attrs:{start:"14"}},[a("li",[a("strong",[t._v("libraryExport")])])]),t._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[t._v("在 Webpack 中，`libraryExport` 是一个配置选项，用于指定库导出暴露的内容。当你打包一个库（Library）时，可以使用 `libraryExport` 来指定哪些模块或变量会被导出给用户使用。\n\n常见的用法是将 `libraryExport` 配置为导出某个模块中的特定变量或函数。例如，如果你的库有一个入口文件 `index.js`，并且你想要导出该文件中的特定函数 `myFunction`，你可以这样配置：\n\nmodule.exports = "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//...其他配置")]),t._v("\n  output"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    library"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" 'MyLibrary'"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    libraryTarget"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" 'umd'"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    libraryExport"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" 'myFunction'\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(";\n\n在上面的配置中，`libraryExport` 被设置为 `'myFunction'`，表示只导出 `index.js` 中的 `myFunction` 函数。这样，在使用你的库时，用户只能访问到 `myFunction` 这个函数。\n\n通过合理配置 `libraryExport`，你可以控制库打包后向外暴露的内容，确保用户可以方便地访问到他们需要的部分。\n\n")])])])])}),[],!1,null,null,null);s.default=r.exports}}]);