---
title: '2024年面试题01集合'
date: '2024'
categories:
  - 面试题
tags:
  - 面试题
---

## 1. 属性修改如何处理响应式

处理响应式属性修改的关键在于跟踪属性的变化并在变化时触发相应的操作。这可以通过使用响应式编程库、框架或原生 JavaScript 实现。以下是一些建议：

1. 使用响应式编程库或框架：许多库和框架，如 RxJS、MobX、Vue.js 和 React 等，提供了处理响应式数据的功能。这些库通常提供了观察者模式、数据绑定和计算属性等功能，可以帮助你轻松地处理属性修改。

2. 使用 Proxy 对象：JavaScript 中的 Proxy 对象可以用来拦截和处理对象的操作，如读取、修改和删除属性。通过创建一个代理对象，你可以在属性被修改时执行自定义操作。

```javascript
const target = { key: 'value' }

const handler = {
  set: function (obj, prop, value) {
    console.log(`属性 ${prop} 被修改为 ${value}`)
    obj[prop] = value
    return true
  },
}

const proxy = new Proxy(target, handler)

proxy.key = 'newValue' // 输出：属性 key 被修改为 newValue
```

3. 使用 getter 和 setter：在 JavaScript 中，你可以使用 getter 和 setter 方法来拦截属性的读取和修改操作。这样，你可以在属性被修改时执行自定义操作。

```javascript
const obj = {
  _key: 'value',
  get key() {
    return this._key
  },
  set key(value) {
    console.log(`属性 key 被修改为 ${value}`)
    this._key = value
  },
}

obj.key = 'newValue' // 输出：属性 key 被修改为 newValue
```

4. 使用事件监听：如果你的应用程序使用了事件驱动的架构，你可以在属性修改时触发事件，并在需要响应属性修改的地方监听这些事件。

```javascript
class MyObject {
  constructor() {
    this.key = 'value'
    this.addEventListener('keyChanged', this.handleKeyChanged)
  }

  setKey(value) {
    this.key = value
    this.dispatchEvent(new CustomEvent('keyChanged', { detail: value }))
  }

  handleKeyChanged(event) {
    console.log(`属性 key 被修改为 ${event.detail}`)
  }
}

const obj = new MyObject()
obj.setKey('newValue') // 输出：属性 key 被修改为 newValue
```

总之，处理响应式属性修改的方法取决于你的应用程序和需求。你可以根据自己的需求选择合适的方法。

## 2. package.json 和 npm ，yarn ，pnpm 的关系

`package.json` 是一个 JSON 格式的文件，用于描述一个 npm 包的基本信息、依赖以及各种配置项。而 `npm` 、 `yarn` 和 `pnpm` 是三种不同的 JavaScript 包管理工具，用于安装、升级、删除和发布 npm 包。这三种工具都使用 `package.json` 文件来管理依赖和配置，可以读取 `package.json` 文件并从 npm 仓库中下载依赖进行安装。它们之间的主要区别在于性能、安全性、易用性和兼容性等方面。

- `npm` 是 Node.js 的默认包管理器，已经成为 JavaScript 生态系统中最受欢迎的包管理器之一。
- `yarn` 是由 Facebook 开发的一个新型包管理工具，旨在提高 npm 的性能和可靠性。
- `pnpm` 是另一个 JavaScript 包管理工具，与 npm 和 yarn 类似，但它利用了硬链接和符号链接而不是复制模块来减少磁盘占用空间。

无论使用哪个包管理工具， `package.json` 文件都是必须的，并且它们都通过读取 `package.json` 文件中的依赖关系来确定安装哪些包。

## 3. 低代码平台具体是怎么实现的

按照我的理解呢，低代码主要是为了解决项目的开发效率和节约人力成本，以及给到其他部门也可以快速搭建一个活动页。
底层实现就是通过数据取生成我们的页面，比如当我的一个 数据表示我需要渲染一个 button 按钮的时候，那么我们会规定，type 为 button style 控制其长宽等样式 事件的处理将
通过，在设计器书写，渲染过程中将设计器书写传递下来的函数，对接到 真实的 dom 事件上，这就简单实现了前端层面的生成 dom，点击触发事件
当我们将所需的页面布局都整理完善后，我们需要保证数据的不丢失，这个时候就可以使用服务器对其进行一个数据的存储。

## 4. 前端模块化详解

#### 1. 什么是模块化

1. 将一个复杂的程序依据一定的规则封装成几个文件，并组合在一起
2. 模块内部数据与实现是私有的，只是向外暴露一些接口与外部其他模块进行通信

##### 2. 模块化的进化过程

###### 1. **全局 function 模式：将不同的功能封装成不同的全局函数**

缺点：

1.  将不同的功能封装成不同的全局函数
2.  污染全局命名空间，容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系

###### 2. **命名空间模式**

优点：将代码包装在一个对象中，减少全局变量解决命名冲突

缺点：数据不安全，外部可以直接修改模块内部的数据

###### 3. **LLFE 模式：匿名函数自调用也就是闭包**

已经实现了数据私有化，外部只能通过暴露的方法操作，通过将数据和行为封装到一个函数内部，通过给 window 添加属性来向外暴露接口

问题点：**如果这个模块内部依赖于另一个模块怎么办？**

可以引入依赖去解决，通过将 其他模块的变量传入，但是这还不是最终解决方法

```js
!(function (window, $) {
  // 这里就可以使用 $
  // 最后给window添加属性并暴露出去
  window.xxx = xxx
})(window, $)
```

#### 3. 模块化的好处

1. 避免命名冲突
2. 更好的分离，按需加载
3. 更高复用性
4. 高可维护性

#### 4. 引入多个 script 后出现的问题

难以维护，依赖模糊，换一个基础薄弱的开发者，既可以导致，依赖乱序，项目报错

#### 5. 模块化规范方案

##### 1. Commonjs

理解：

1. 每一个文件就是一个模块，有自己的作用域，在一个文件里面定义的变量，函数，类都是私有的，对其他文件不可见，**在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理**

特点：

1. 所有代码都运行在模块作用域，不会污染全局作用域
2. 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存的结果，
3. 模块加载的顺序，按照其在代码中出现的顺序

commonjs 模块的加载机制：**输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值**

##### 2. AMD

CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD 规范则是非同步加载模块，允许指定回调函数。由于 Node.js 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 CommonJS 规范比较适用。但是，**如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用 AMD 规范**。

缺点：
会发送多个请求，其次就是引入文件的顺序不能搞错，否则会报错

##### 3. CMD

CMD 规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。**CMD 规范整合了 CommonJS 和 AMD 规范的特点**

##### 4. ES6 模块化

ES6 模块的设计思想是尽量的静态化，使得**编译时就能确定模块的依赖关系**，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。

##### 5. ES6 模块与 CommonJS 模块的差异

- ① CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。

- ② CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

#### 6. 参考文章

- https://juejin.cn/post/6844903744518389768#comment

## 5. 大文件上传和断点续传是怎么实现的

大文件上传和断点续传主要依赖于分片上传技术。具体实现步骤如下：

1. **分片上传**：将大文件按照一定大小分割成多个数据块（Part），然后分别上传这些数据块。

2. **服务端汇总**：所有数据块上传完成后，服务端将这些数据块汇总整合成原始文件。

3. **断点续传**：在上传过程中，如果遇到网络故障或其他问题导致上传中断，客户端会记录上传进度。当用户再次尝试上传时，客户端会从上次中断的地方继续上传，而不是从头开始。

为了实现断点续传，服务端需要提供相应的接口，以便客户端查询已经上传的分片数据。这样，客户端就可以知道哪些分片已经上传，从而从下一个分片开始继续上传。

#### 代码示例

以下是一个使用 JavaScript 和 HTML 实现的简单分片上传示例。这个示例使用了`FileReader` API 来读取文件内容，并将其分片上传到服务器。

**HTML**:

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>分片上传示例</title>
  </head>
  <body>
    <input type="file" id="fileInput" />
    <button id="uploadBtn">上传</button>
    <script src="main.js"></script>
  </body>
</html>
```

**JavaScript (main.js)**:

```javascript
const fileInput = document.getElementById('fileInput')
const uploadBtn = document.getElementById('uploadBtn')

uploadBtn.addEventListener('click', () => {
  const file = fileInput.files[0]
  if (!file) {
    alert('请选择一个文件')
    return
  }

  const chunkSize = 1024 * 1024 // 1MB
  const totalChunks = Math.ceil(file.size / chunkSize)

  for (let i = 0; i < totalChunks; i++) {
    const start = i * chunkSize
    const end = Math.min(file.size, start + chunkSize)
    const chunk = file.slice(start, end)

    uploadChunk(chunk, i, totalChunks)
  }
})

function uploadChunk(chunk, chunkIndex, totalChunks) {
  const formData = new FormData()
  formData.append('file', chunk)
  formData.append('chunkIndex', chunkIndex)
  formData.append('totalChunks', totalChunks)

  fetch('https://your-server.com/upload', {
    method: 'POST',
    body: formData,
  })
    .then((response) => response.json())
    .then((data) => {
      console.log('分片上传成功:', chunkIndex)
    })
    .catch((error) => {
      console.error('分片上传失败:', chunkIndex, error)
    })
}
```

请注意，这个示例仅用于演示目的。在实际应用中，你需要根据你的服务器端实现来调整上传接口和参数。同时，你还需要考虑断点续传、进度显示、错误处理等功能。

---

为了实现断点续传，我们需要在客户端记录上传进度，并在上传时检查已上传的分片。以下是一个简单的断点续传示例：

**HTML**:

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>分片上传示例</title>
  </head>
  <body>
    <input type="file" id="fileInput" />
    <button id="uploadBtn">上传</button>
    <script src="main.js"></script>
  </body>
</html>
```

**JavaScript (main.js)**:

```javascript
const fileInput = document.getElementById('fileInput')
const uploadBtn = document.getElementById('uploadBtn')

uploadBtn.addEventListener('click', async () => {
  const file = fileInput.files[0]
  if (!file) {
    alert('请选择一个文件')
    return
  }

  const chunkSize = 1024 * 1024 // 1MB
  const totalChunks = Math.ceil(file.size / chunkSize)

  // 获取已上传的分片索引
  const uploadedChunks = await getUploadedChunks(file.name)

  for (let i = 0; i < totalChunks; i++) {
    if (uploadedChunks.includes(i)) {
      console.log('分片已上传:', i)
      continue
    }

    const start = i * chunkSize
    const end = Math.min(file.size, start + chunkSize)
    const chunk = file.slice(start, end)

    await uploadChunk(chunk, i, totalChunks, file.name)
  }
})

async function getUploadedChunks(fileName) {
  // 从服务器获取已上传的分片索引
  // 这里需要根据你的服务器端实现来调整
  const response = await fetch(
    `https://your-server.com/uploaded-chunks?fileName=${encodeURIComponent(
      fileName
    )}`
  )
  const data = await response.json()
  return data.uploadedChunks
}

function uploadChunk(chunk, chunkIndex, totalChunks, fileName) {
  return new Promise((resolve, reject) => {
    const formData = new FormData()
    formData.append('file', chunk)
    formData.append('chunkIndex', chunkIndex)
    formData.append('totalChunks', totalChunks)
    formData.append('fileName', fileName)

    fetch('https://your-server.com/upload', {
      method: 'POST',
      body: formData,
    })
      .then((response) => response.json())
      .then((data) => {
        console.log('分片上传成功:', chunkIndex)
        resolve()
      })
      .catch((error) => {
        console.error('分片上传失败:', chunkIndex, error)
        reject(error)
      })
  })
}
```

请注意，这个示例仅用于演示目的。在实际应用中，你需要根据你的服务器端实现来调整上传接口和参数。同时，你还需要考虑进度显示、错误处理等功能。
