---
title: '2024年面试题02集合'
date: '2024'
categories:
  - 面试题
tags:
  - 面试题
---

## 1. 微前端中 子系统如何做数据共享，子系统和主系统如何做样式隔离

微前端架构中，子系统与主系统之间的数据共享和样式隔离是两个重要的问题。以下是一些建议来帮助您实现这两个目标：

1. 数据共享：

在微前端架构中，有多种方法可以实现子系统与主系统之间的数据共享。以下是一些建议：

- 使用全局状态管理库：如 Redux、Vuex 或 MobX 等，可以在主系统和子系统中使用相同的全局状态管理库，从而实现数据共享。

- 使用 postMessage API：子系统可以通过 postMessage API 向主系统发送消息，主系统监听这些消息并作出相应的响应。这是一种轻量级的通信方式，适用于不频繁的数据交换。

- 使用单例服务：创建一个单例服务，主系统和子系统都可以通过该服务获取和设置数据。这种方法适用于需要在多个子系统之间共享的数据。

2. 样式隔离：

为了避免子系统的样式影响主系统的样式，可以采取以下措施：

- 使用 CSS 命名空间：为子系统的 CSS 类名添加前缀，以确保它们不会与主系统的类名冲突。例如，子系统的类名可以命名为`my-subsystem-component`。

- 使用 CSS 模块：CSS 模块可以将 CSS 类名局部作用域化，确保它们只在子组件内部生效。这样，即使子系统和主系统使用了相同的类名，也不会产生冲突。

- 使用 Shadow DOM：Shadow DOM 可以为子组件创建独立的 DOM 树，从而隔离子组件的样式。这种方法可以确保子组件的样式不会影响主系统的样式，但需要浏览器支持（目前大多数现代浏览器都支持）。

- 使用 CSS-in-JS 库：如 styled-components 或 emotion 等，可以将 CSS 样式直接编写在 JavaScript 中，并通过组件的作用域进行隔离。这样可以避免类名冲突，但需要引入额外的库。

结合以上方法，您可以在微前端架构中实现中子系统与主系统之间的数据共享和样式隔离。

## 2. indexDB 的原理

IndexedDB 是一个在浏览器端存储数据的方式，它是一个 key-value 型的数据库。IndexedDB 的原理主要包括以下几个方面：

1. **数据库连接**：要使用 IndexedDB，首先需要打开它。这可以通过调用`window.indexedDB.open()`方法来完成，该方法返回一个 IDBOpenDBRequest 对象。

2. **版本控制**：每个数据库都有一个版本号，当创建一个新的数据库或升级现有数据库版本时，会触发`onupgradeneeded`事件。在这个事件中，可以创建新的 objectStore 或更新现有 objectStore 的 schema。

3. **事务处理**：IndexedDB 的所有操作都需要在事务中完成。事务可以用于读取、写入或删除数据。事务由`IDBTransaction`对象表示，它可以是只读、读写或版本更新事务。

4. **对象存储**：IndexedDB 中的数据以对象存储（objectStore）的形式存储。每个 objectStore 都有一个唯一的键（key），可以是任何 JavaScript 值，包括对象、基本类型和数组。

5. **索引**：可以为 objectStore 创建索引，以提高查询速度。索引可以是唯一的，也可以是非唯一的。

6. **异步操作**：IndexedDB API 大部分都是异步的，这意味着它们不会立即返回结果。而是返回一个回调函数，当操作完成时，会通过事件通知结果。

7. **同源策略**：IndexedDB 具有同源策略，这意味着每个源只能访问与其关联的数据库集合。这有助于保护用户数据免受跨站点攻击。

总之，IndexedDB 的原理包括数据库连接、版本控制、事务处理、对象存储、索引、异步操作和同源策略。这些原理共同构成了 IndexedDB 的核心功能，使其成为一个强大且安全的客户端存储解决方案。

## 3. vue 性能优化

Vue.js 是一个用于构建用户界面的渐进式框架。为了确保应用程序的性能和响应速度，可以采取以下策略进行优化：

1. 使用 Vue 生产版本：确保在生产环境中使用 Vue 的生产版本，因为它不包含开发时的警告和错误检查。

2. 使用 vue-loader 进行按需引入：通过使用 vue-loader，可以实现 Vue 组件的按需引入，从而减少最终打包文件的大小。

3. 使用 vue-router 的懒加载：通过使用 vue-router 的懒加载功能，可以按需加载路由组件，从而实现更快的页面加载速度。

4. 使用 key 属性：为列表渲染中的元素提供唯一的 key，可以帮助 Vue 更高效地更新 DOM。

5. 使用 v-once 和 v-memo：对于不需要改变的静态内容，可以使用 v-once 指令，这样 Vue 就不会对其进行重新渲染。对于需要缓存的计算属性或方法，可以使用 v-memo 指令。

6. 使用计算属性和侦听器：将复杂的计算和操作封装在计算属性和侦听器中，可以避免不必要的重新计算和更新。

7. 使用 Vue 的异步组件：通过将组件异步加载，可以实现更快的页面加载速度。

8. 使用 keep-alive 缓存组件：对于需要频繁切换的组件，可以使用 keep-alive 指令将其缓存，从而提高性能。

9. 优化事件监听器：避免在组件内部使用过多的事件监听器，可以使用 Vue 的事件修饰符（如 .once、.capture 等）来优化事件处理。

10. 使用 Vue 的生产提示：在开发过程中，可以使用 Vue 的生产提示功能来检查潜在的性能问题。

11. 使用 Webpack 代码分割：通过使用 Webpack 的代码分割功能，可以将应用程序拆分为更小的代码块，从而实现更快的页面加载速度。

12. 使用 Vue 的服务器端渲染（SSR）：通过使用 Vue 的服务器端渲染功能，可以将页面的初始渲染过程从客户端移到服务器端，从而提高首屏加载速度。

13. 使用 Vue 的静态资源分析：通过使用 Vue 的静态资源分析工具，可以检查应用程序的静态资源使用情况，从而优化性能。

14. 使用 Vue 的性能分析工具：通过使用 Vue 的性能分析工具，可以检查应用程序的性能瓶颈，从而进行优化。

## 4. 路由实现的原理

路由的实现主要是依靠浏览器提供的**历史记录 api** ，通过监听路由历史记录的变化，从而对应的去加载页面

1. 分为两种路由模式 hash 路由 和 history 路由

2. hash 路由 使用 window.onhashchange，并且在浏览器地址拦中会出现一个 #

3. history 路由 使用
   - history.go history.back history.forward 只能使用 popstate 事件 监听 window.onpopstate
   - history.pushState history.replaceState 无法被监听到，需要通过函数重写到方式进行劫持

## 5. http 缓存有哪些，有什么区别？

HTTP 缓存主要有两种类型：强制缓存（强缓存）和协商缓存。它们之间的区别如下：

1. **强制缓存**：

- 直接使用客户端缓存，不从服务器拉取新资源，也不验证缓存资源是否过期。
- 返回的状态码为 200（OK）。
- 基于 Expires 字段或 Cache-Control 字段实现。

2. **协商缓存**：

- 通过服务器验证资源有效性，资源有效则返回 304（Not Modified），资源失效则返回最新的资源文件。
- 客户端缓存失效后会向服务器进行进行缓存有效性验证。
- 基于 Last-modified 或 ETag 实现。

总结来说，强制缓存直接使用客户端缓存，而协商缓存则需要服务器验证资源有效性。强制缓存返回状态码 200，而协商缓存返回状态码 304。

## 6. TypeScript 中的 type 和 interface 的理解

首先认识一下什么是类型别名？类型别名不仅可以用来表示基本类型，还可以用来表示对象类型、联合类型、元组和交集。

```ts
type num = number // 基本类型

type Cat = number | string // 联合类型

type arr = [number, string] // 元组

type arr1 = string[] // 数组

type tree<T> = { value: T } // 范型
```

接口 interface 接口是命名数据结构（例如对象）的另一种方式；与 type 不同，interface 仅限于描述对象类型。

```ts
interface Person {
  id: userId
}
```

**interface 和 type 的相似之处**:

1. 都可以描述 Object 和 Function

```ts
type obj = { name: string }

interface obj1 {
  name: string
}

//
type fun = () => void

interface fun1 {
  (): void
}
```

2. 二者都可以被继承,且互相都可以继承对方

```ts
// interface 继承 interface
interface obj1 {
  name: string
}

interface fun1 extends obj1 {
  (): void
}

const abc: fun1 = Object.assign(() => {
  console.log('ok')
})

// interface 继承 type
type obj = { name: string }

interface obj1 extends obj {
  age: string
}

const abc: obj1 = {
  name: 'jack',
  age: '18',
}

// type 继承 type

type obj = { name: string }

type obj1 = { age: number }

type obj2 = obj & obj1

const abc: obj2 = {
  name: 'jack',
  age: 19,
}

// type 继承 interface

type obj = { name: string }

interface obj1 {
  age: number
}

type obj2 = obj & obj1

const abc: obj2 = {
  name: 'jack',
  age: 18,
}
```

3. interface 以及 type 都可以去 implements 实现类**但是 实现 type 联合类型不行**

```ts
interface Ik {
  setName(): void
}

class Person implements Ik {
  setName(): void {}
}

type IJ = {
  setAge(): void
}

class Person1 implements IJ {
  setAge(): void {}
}
```

**interface 和 type 的不同之处**:

1. type 可以定义基本类型别名, 但是 interface 无法定义
2. type 可以声明联合类型，但是 interface 无法定义
3. type 可以声明 元组类型，但是 interface 无法定义
4. interface 可以进行声明合并 ，而 type 无法这样做
   - 如果你多次声明一个同名的接口，TypeScript 会将它们合并到一个声明中，并将它们视为一个接口。这称为声明合并

**索引签名问题**

我们经常可以看到 `不能将类型“xxx”分配给类型“xxxx”。类型“xxxx”中缺少类型“xxxx”的索引签名` 的报错。

```ts
interface propType {
  [key: string]: string
}
let props: propType
type dataType = {
  title: string
}
interface dataType1 {
  title: string
}
const data: dataType = { title: '订单页面' }
const data1: dataType1 = { title: '订单页面' }
props = data

// Error:类型“dataType1”不可分配给类型“propType”; 类型“dataType1”中缺少索引签名
props = data1
```

为什么 dataType 和 dataType1 所申明的类型都差不多，但是 interface 定义的就赋值失败，是什么原因呢？

答：主要原因就是 使用 interface 去声明变量时，它们在那一刻类型并不是最终的类型，你有可能会在另一个地方使用相同名字的声明(**interface 可以进行声明合并**)，所以总有可能将新成员添加到同一个 interface 定义的类型上。

## 7. vue3 setup 语法糖做了什么

**vue 文件如何渲染到浏览器上**
首先，我们知道 .vue 文件，浏览器肯定是不认识的，浏览器只认识 html, css,js 。所以只有通过 webpack 或者 vite 将一个 vue 文件编译为一个包含 render 函数的 js 文件。然后执行 render 函数生成虚拟 DOM，再调用浏览器的 DOM API 根据虚拟 DOM 生成真实 DOM 挂载到浏览器上。

<img :src="$withBase('/38.png')" width="100%" height="100%" alt="1" />

**setup 编译后的样子**

```vue
<!-- 原始文件 这里我们定义了一个名为msg的ref响应式变量和非响应式的title变量，还有import了child.vue组件。 -->

<template>
  <h1>{{ title }}</h1>
  <h1>{{ msg }}</h1>
  <Child />
</template>

<script lang="ts" setup>
import { ref } from 'vue'
import Child from './child.vue'

const msg = ref('Hello World!')
const title = 'title'
if (msg.value) {
  const content = 'content'
  console.log(content)
}
</script>
```

```js
// 编译后 生成 render函数和__sfc__对象。并且使用__sfc__.render = render 将render函数挂到__sfc__对象上，然后将__sfc__对象export default出去。

import { ref } from 'vue'
import Child from './Child.vue'

const title = 'title'

const __sfc__ = {
  __name: 'index',
  setup() {
    const msg = ref('Hello World!')
    if (msg.value) {
      const content = 'content'
      console.log(content)
    }
    const __returned__ = { title, msg, Child }
    return __returned__
  },
}

import {
  toDisplayString as _toDisplayString,
  createElementVNode as _createElementVNode,
  createVNode as _createVNode,
  Fragment as _Fragment,
  openBlock as _openBlock,
  createElementBlock as _createElementBlock,
} from 'vue'
function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (
    _openBlock(),
    _createElementBlock(
      _Fragment,
      null,
      [
        _createElementVNode('h1', null, _toDisplayString($setup.title)),
        _createElementVNode(
          'h1',
          null,
          _toDisplayString($setup.msg),
          1 /* TEXT */
        ),
        _createVNode($setup['Child']),
      ],
      64 /* STABLE_FRAGMENT */
    )
  )
}
__sfc__.render = render
export default __sfc__
```

1. 我们发现 title 这种未通过响应声明的变量，会被提升到全局作用域中
2. script 被编译成了一个 `__sfc__ ` 的对象，内部包裹着 setup 函数，最后返回一个对象，里面 包含着声明的变量，以及 组件，这也就解释了，为什么 在 setup 语法糖下，引入了组件就直接注册了
3. template 模版编译成了一个 render 函数，通过 render 函数生成虚拟 DOM，
4. render 函数中 大量使用了 `$setup.xxx`, $setup 是一个对象，从里面得到了 在 setup 声明的 一些变量和组件，所以，$setup 和 setup 函数返回的对象是一个东西

答：setup 语法糖经过编译后就变成了 setup 函数，而 setup 函数的返回值是一个对象，这个对象就是由在 setup 顶层定义的变量和 import 导入组成的，vue 在初始化的时候会执行 setup 函数，然后将 setup 函数返回值塞到 vue 实例属性上，执行 render 函数的时候会将 vue 实例上属性（也就是 setup 函数的返回值）传递给 render 函数，所以在 render 函数中就可以访问到 setup 顶层定义的变量和 import 导入。而 render 函数实际就是由 template 编译得来的，所以说在 template 中就可以访问到 setup 顶层定义的变量和 import 导入。
