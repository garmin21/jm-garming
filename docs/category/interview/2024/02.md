---
title: '2024年面试题02集合'
date: '2024'
categories:
  - 面试题
tags:
  - 面试题
---

## 1. 微前端中 子系统如何做数据共享，子系统和主系统如何做样式隔离

微前端架构中，子系统与主系统之间的数据共享和样式隔离是两个重要的问题。以下是一些建议来帮助您实现这两个目标：

1. 数据共享：

在微前端架构中，有多种方法可以实现子系统与主系统之间的数据共享。以下是一些建议：

- 使用全局状态管理库：如 Redux、Vuex 或 MobX 等，可以在主系统和子系统中使用相同的全局状态管理库，从而实现数据共享。

- 使用 postMessage API：子系统可以通过 postMessage API 向主系统发送消息，主系统监听这些消息并作出相应的响应。这是一种轻量级的通信方式，适用于不频繁的数据交换。

- 使用单例服务：创建一个单例服务，主系统和子系统都可以通过该服务获取和设置数据。这种方法适用于需要在多个子系统之间共享的数据。

2. 样式隔离：

为了避免子系统的样式影响主系统的样式，可以采取以下措施：

- 使用 CSS 命名空间：为子系统的 CSS 类名添加前缀，以确保它们不会与主系统的类名冲突。例如，子系统的类名可以命名为`my-subsystem-component`。

- 使用 CSS 模块：CSS 模块可以将 CSS 类名局部作用域化，确保它们只在子组件内部生效。这样，即使子系统和主系统使用了相同的类名，也不会产生冲突。

- 使用 Shadow DOM：Shadow DOM 可以为子组件创建独立的 DOM 树，从而隔离子组件的样式。这种方法可以确保子组件的样式不会影响主系统的样式，但需要浏览器支持（目前大多数现代浏览器都支持）。

- 使用 CSS-in-JS 库：如 styled-components 或 emotion 等，可以将 CSS 样式直接编写在 JavaScript 中，并通过组件的作用域进行隔离。这样可以避免类名冲突，但需要引入额外的库。

结合以上方法，您可以在微前端架构中实现中子系统与主系统之间的数据共享和样式隔离。

## 2. indexDB 的原理

IndexedDB 是一个在浏览器端存储数据的方式，它是一个 key-value 型的数据库。IndexedDB 的原理主要包括以下几个方面：

1. **数据库连接**：要使用 IndexedDB，首先需要打开它。这可以通过调用`window.indexedDB.open()`方法来完成，该方法返回一个 IDBOpenDBRequest 对象。

2. **版本控制**：每个数据库都有一个版本号，当创建一个新的数据库或升级现有数据库版本时，会触发`onupgradeneeded`事件。在这个事件中，可以创建新的 objectStore 或更新现有 objectStore 的 schema。

3. **事务处理**：IndexedDB 的所有操作都需要在事务中完成。事务可以用于读取、写入或删除数据。事务由`IDBTransaction`对象表示，它可以是只读、读写或版本更新事务。

4. **对象存储**：IndexedDB 中的数据以对象存储（objectStore）的形式存储。每个 objectStore 都有一个唯一的键（key），可以是任何 JavaScript 值，包括对象、基本类型和数组。

5. **索引**：可以为 objectStore 创建索引，以提高查询速度。索引可以是唯一的，也可以是非唯一的。

6. **异步操作**：IndexedDB API 大部分都是异步的，这意味着它们不会立即返回结果。而是返回一个回调函数，当操作完成时，会通过事件通知结果。

7. **同源策略**：IndexedDB 具有同源策略，这意味着每个源只能访问与其关联的数据库集合。这有助于保护用户数据免受跨站点攻击。

总之，IndexedDB 的原理包括数据库连接、版本控制、事务处理、对象存储、索引、异步操作和同源策略。这些原理共同构成了 IndexedDB 的核心功能，使其成为一个强大且安全的客户端存储解决方案。

## 3. vue 性能优化

Vue.js 是一个用于构建用户界面的渐进式框架。为了确保应用程序的性能和响应速度，可以采取以下策略进行优化：

1. 使用 Vue 生产版本：确保在生产环境中使用 Vue 的生产版本，因为它不包含开发时的警告和错误检查。

2. 使用 vue-loader 进行按需引入：通过使用 vue-loader，可以实现 Vue 组件的按需引入，从而减少最终打包文件的大小。

3. 使用 vue-router 的懒加载：通过使用 vue-router 的懒加载功能，可以按需加载路由组件，从而实现更快的页面加载速度。

4. 使用 key 属性：为列表渲染中的元素提供唯一的 key，可以帮助 Vue 更高效地更新 DOM。

5. 使用 v-once 和 v-memo：对于不需要改变的静态内容，可以使用 v-once 指令，这样 Vue 就不会对其进行重新渲染。对于需要缓存的计算属性或方法，可以使用 v-memo 指令。

6. 使用计算属性和侦听器：将复杂的计算和操作封装在计算属性和侦听器中，可以避免不必要的重新计算和更新。

7. 使用 Vue 的异步组件：通过将组件异步加载，可以实现更快的页面加载速度。

8. 使用 keep-alive 缓存组件：对于需要频繁切换的组件，可以使用 keep-alive 指令将其缓存，从而提高性能。

9. 优化事件监听器：避免在组件内部使用过多的事件监听器，可以使用 Vue 的事件修饰符（如 .once、.capture 等）来优化事件处理。

10. 使用 Vue 的生产提示：在开发过程中，可以使用 Vue 的生产提示功能来检查潜在的性能问题。

11. 使用 Webpack 代码分割：通过使用 Webpack 的代码分割功能，可以将应用程序拆分为更小的代码块，从而实现更快的页面加载速度。

12. 使用 Vue 的服务器端渲染（SSR）：通过使用 Vue 的服务器端渲染功能，可以将页面的初始渲染过程从客户端移到服务器端，从而提高首屏加载速度。

13. 使用 Vue 的静态资源分析：通过使用 Vue 的静态资源分析工具，可以检查应用程序的静态资源使用情况，从而优化性能。

14. 使用 Vue 的性能分析工具：通过使用 Vue 的性能分析工具，可以检查应用程序的性能瓶颈，从而进行优化。

## 4. 路由实现的原理

路由的实现主要是依靠浏览器提供的**历史记录 api** ，通过监听路由历史记录的变化，从而对应的去加载页面

1. 分为两种路由模式 hash 路由 和 history 路由

2. hash 路由 使用 window.onhashchange，并且在浏览器地址拦中会出现一个 #

3. history 路由 使用
   - history.go history.back history.forward 只能使用 popstate 事件 监听 window.onpopstate
   - history.pushState history.replaceState 需要通过函数重写到方式进行劫持

## 5. http 缓存有哪些，有什么区别？

HTTP 缓存主要有两种类型：强制缓存（强缓存）和协商缓存。它们之间的区别如下：

1. **强制缓存**：

- 直接使用客户端缓存，不从服务器拉取新资源，也不验证缓存资源是否过期。
- 返回的状态码为 200（OK）。
- 基于 Expires 字段或 Cache-Control 字段实现。

2. **协商缓存**：

- 通过服务器验证资源有效性，资源有效则返回 304（Not Modified），资源失效则返回最新的资源文件。
- 客户端缓存失效后会向服务器进行进行缓存有效性验证。
- 基于 Last-modified 或 ETag 实现。

总结来说，强制缓存直接使用客户端缓存，而协商缓存则需要服务器验证资源有效性。强制缓存返回状态码 200，而协商缓存返回状态码 304。
