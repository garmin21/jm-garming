---
title: 2-20 前端模块化详解
date: '2023-02-16'
categories:
    - 面试题
tags:
    - 面试题
---

## 1. 什么是模块化

1. 将一个复杂的程序依据一定的规则封装成几个文件，并组合在一起
2. 模块内部数据与实现是私有的，只是向外暴露一些接口与外部其他模块进行通信

## 2. 模块化的进化过程

### 1. **全局 function 模式：将不同的功能封装成不同的全局函数**

缺点：

1.  将不同的功能封装成不同的全局函数
2.  污染全局命名空间，容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系

### 2. **命名空间模式**

优点：将代码包装在一个对象中，减少全局变量解决命名冲突

缺点：数据不安全，外部可以直接修改模块内部的数据

### 3. **LLFE 模式：匿名函数自调用也就是闭包**

已经实现了数据私有化，外部只能通过暴露的方法操作，通过将数据和行为封装到一个函数内部，通过给 window 添加属性来向外暴露接口

问题点：**如果这个模块内部依赖于另一个模块怎么办？**

可以引入依赖去解决，通过将 其他模块的变量传入，但是这还不是最终解决方法

```js
!(function (window, $) {
    // 这里就可以使用 $
    // 最后给window添加属性并暴露出去
    window.xxx = xxx
})(window, $)
```

## 3. 模块化的好处

1. 避免命名冲突
2. 更好的分离，按需加载
3. 更高复用性
4. 高可维护性

## 4. 引入多个 script 后出现的问题

难以维护，依赖模糊，换一个基础薄弱的开发者，既可以导致，依赖乱序，项目报错

## 5. 模块化规范方案

### 1. Commonjs

理解：

1. 每一个文件就是一个模块，有自己的作用域，在一个文件里面定义的变量，函数，类都是私有的，对其他文件不可见，**在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理**

特点：

1. 所有代码都运行在模块作用域，不会污染全局作用域
2. 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存的结果，
3. 模块加载的顺序，按照其在代码中出现的顺序

commonjs 模块的加载机制：**输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值**

### 2. AMD

CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD 规范则是非同步加载模块，允许指定回调函数。由于 Node.js 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 CommonJS 规范比较适用。但是，**如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用 AMD 规范**。

缺点：
会发送多个请求，其次就是引入文件的顺序不能搞错，否则会报错

### 3. CMD

CMD 规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。**CMD 规范整合了 CommonJS 和 AMD 规范的特点**

### 4. ES6 模块化

ES6 模块的设计思想是尽量的静态化，使得**编译时就能确定模块的依赖关系**，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。

### 5. ES6 模块与 CommonJS 模块的差异

-   ① CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。

-   ② CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

## 6. 参考文章

-   https://juejin.cn/post/6844903744518389768#comment
